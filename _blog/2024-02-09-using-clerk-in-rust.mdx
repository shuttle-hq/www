---
title: "Using Clerk authentication in Rust"
description: This article is on how to use Clerk authentication in Rust based back-end applications and little bit of an extension on integration of shared database using Shuttle. 
author: sourabpramanik
tags: [rust, clerk, vite, guide]
thumb: 
cover: 
date: 
---

In this article, I have shared how I built an Issue tracking application using Vite for the front-end, and [Shuttle](https://www.shuttle.rs/) and [Actix web](https://actix.rs/) for the back-end. In addition to that I have also used [Clerk](https://clerk.com/) for authentication in the front-end and protecting the endpoints in the back-end.

Here is the [source code](https://github.com/sourabpramanik/issue-tracker) of the complete project if you want to follow along.

To start this project I have used the template from Shuttle’s [example repository](https://github.com/shuttle-hq/shuttle-examples) that has a barebone setup of Vite, Shuttle, Actix web, and Clerk. 

The back-end uses [clerk-rs](https://github.com/DarrenBaldwin07/clerk-rs) crate to create a connection between the back-end application and Clerk project. This crate has many different APIs for different use cases, in the template there is back-end API to fetch all users record using `clerk-rs` user API. We can easily verify user's identity trying to access protected routes before hand using the `ClerkMiddleware` from the crate.

I have additionally used Postgres for the database which will run in a docker container so make sure you also have docker [installed](https://docs.docker.com/engine/install/).


# Let's get started

First, we need to clone the template from the Shuttle’s example repository using Shuttle CLI:

```bash
cargo shuttle init --from shuttle-hq/shuttle-examples --subfolder actix-web/clerk

```

You will get a few prompts to create a new project using this template. Make sure you provide a unique name because when you deploy this project on Shuttle this project name will become the sub-domain. And once a name is taken it cannot be used for other project as well:

```bash
What do you want to name your project?
It will be hosted at ${project_name}.shuttleapp.rs, so choose something unique!
✔ Project name · <ENTER_PROJECT_NAME>
Where should we create this project?
✔ Directory · <ENTER_THE_DIRECTORY_NAME>
✔ Claim the project name <PROJECT_NAME> by starting a project container on Shuttle? <Y/N>

```

After that, `cd` into the project directory:

```bash
cd {project_name}

```

## Setup a new application in Clerk

Head on to Clerk’s official website, sign in or sign up if don’t have an account, and create a new application in the dashboard.

Give a name to your project and select the providers using which users can sign-in or sign-up in your application.

After that, you will get a **Publishable Key** and a **Secret key** which we will use later in our application.

[https://gist.github.com/assets/61370770/7fb52565-605c-42e9-9a6a-3fc7e4855696](https://gist.github.com/assets/61370770/7fb52565-605c-42e9-9a6a-3fc7e4855696)

## Build the back-end

Now we can start updating the existing back-end code to write and build our own endpoints for our application.

`cd` into the backend:

```bash
cd backend

```

Copy the contents of `Secrets.example.toml` into a new `Secrets.toml` file:

```bash
touch Secrets.toml
cp Secrets.example.toml Secrets.toml

```

Copy the **Secret key** from the Clerk dashboard and add it to `Secrets.toml` :

```bash
CLERK_SECRET_KEY = "sk_test_vsWrxxxxxxxxxxxxxxxxxxxxxxxxxtfTr"

```

> ⚠️ Do not commit this file
> 

Now, we need to write a new migration in a `schema.sql` file which will create a new `issues` table in our Postgres database.

Create `schema.sql` and add the schema:

```sql
-- Create a non-existing table
CREATE TABLE IF NOT EXISTS issues (
  id SERIAL PRIMARY KEY,
  title VARCHAR(100) NOT NULL,
  description VARCHAR(300) NOT NULL,
  status VARCHAR(10) NOT NULL,
  label VARCHAR(10) NOT NULL,
  author VARCHAR NOT NULL
);

```

We can migrate this schema using **[SQLX](https://docs.rs/sqlx/latest/sqlx/)**. So add the SQLX crate to your dependency:

```bash
cargo add sqlx

```

To connect to a shared Postgres database managed by Shuttle you need to add the crate with features specific to Postgres and SQLX to your dependencies:

```bash
cargo add shuttle-shared-db -F shuttle-shared-db/postgres -F shuttle-shared-db/sqlx

```

> 🗨️ Even though the database is shared our data is protected and kept secured from other users by Shuttle.
> 

### Connect to the shared Postgres DB

Let’s migrate this schema, `cd` into the `src` directory, and write some code in the `main.rs` file.

First, we need to bring SQLX into the scope:

```rust
use sqlx::{Executor, FromRow, PgPool};

```

Add the pool field to the `AppState` struct to share the Postgres pool instance in our whole application:

```rust
struct AppState {
    client: Clerk,
    pool: PgPool,
}

```

Next, pass the `#[shuttle_shared_db::Postgres] pool: PgPool` argument to your `shuttle_runtime::main` function and connect to Postgres using SQLX connect pool `PgPool`.

```rust
#[shuttle_runtime::main]
async fn actix_web(
    #[shuttle_secrets::Secrets] secrets: SecretStore,
    #[shuttle_shared_db::Postgres] pool: PgPool,
) -> ShuttleActixWeb<impl FnOnce(&mut ServiceConfig) + Send + Clone + 'static> {
    // DB Pool
    pool.execute(include_str!("../schema.sql"))
        .await
        .map_err(CustomError::new)?;

    // Clerk integration
    let clerk_secret_key = secrets
        .get("CLERK_SECRET_KEY")
        .expect("Clerk Secret key is not set");
    let clerk_config = ClerkConfiguration::new(None, None, Some(clerk_secret_key), None);
    let client = Clerk::new(clerk_config.clone());

    // Create new app state
    let state = web::Data::new(AppState { client, pool });

    let app_config = move |cfg: &mut ServiceConfig| {
        cfg.service(
            web::scope("/api")
                .wrap(ClerkMiddleware::new(clerk_config, None, true))
                .service(get_user)
        )
        .service(actix_files::Files::new("/", "./frontend/dist").index_file("index.html"))
        .app_data(state);
    };

    Ok(app_config.into())
}

```

The above function call will create the Postgres pool, and then SQLX will migrate the schema we have created before. The Clerk configuration is already defined in the template for us which uses the `CLERK_SECRET_KEY` we got from the Clerk project we have created earlier.

The Clerk middleware will protect all the APIs that falls under the scope `/api`.

Try running the application using Shuttle CLI:

```bash
cargo shuttle run --port 8000

```

> 🗨️ Make sure docker is running in your local machine because after you run the above command Shuttle will pull the Postgres docker image and start a docker container.
> 

The back-end application can now query the Postgres database using SQLX. Let's create some **CRUD** endpoints for our application.

### Create Issue struct

To define the fields of an issue we will create a new struct that is used to define the response and request payload of our **Read, Update,** and **Delete** queries:

```rust
#[derive(Serialize, Deserialize, FromRow)]
struct Issue {
    title: String,
    description: String,
    status: String,
    label: String,
    author: String,
}

```

### Create NewIssue struct

To define the new issue request payload for our create API endpoint we will use this struct:

```rust
#[derive(Serialize, Deserialize, FromRow)]
struct NewIssue {
    title: String,
    description: String,
    status: String,
    label: String,
    author: String,
}

```

### Create issue endpoint

Add the create issue endpoint which can query our database to insert a new issue into the table like this:

```rust
#[post("/issue")]
async fn add_issue(payload: web::Json<NewIssue>, state: web::Data<AppState>) -> impl Responder {
    let create_query: Result<Issue, sqlx::Error> = sqlx::query_as(
        "INSERT INTO issues (title, description, status, label, author) VALUES ($1, $2, $3, $4, $5) RETURNING *"
    )
    .bind(&payload.title)
    .bind(&payload.description)
    .bind(&payload.status)
    .bind(&payload.label)
    .bind(&payload.author)
    .fetch_one(&state.pool)
    .await;

    if create_query.is_err() {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "status":"FAILED",
            "message":"Failed to create an issue"
        }));
    }

    HttpResponse::Ok().json(serde_json::json!({
        "status":"SUCCESS",
        "message":"Created the issue successfully"
    }))
}

```

### Retrieve all issues endpoint

This endpoint will retrieve all the issues from the database:

```rust
#[get("/issues")]
async fn get_issues(state: web::Data<AppState>) -> impl Responder {
    let query: Result<Vec<Issue>, sqlx::Error> = sqlx::query_as("SELECT * FROM issues")
        .fetch_all(&state.pool)
        .await;

    let issues = match query {
        Ok(value) => value,
        Err(e) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "status": "FAILED",
                "message": e.to_string(),
            }));
        }
    };

    HttpResponse::Ok().json(issues)
}

```

### Get issue by `id` endpoint

This endpoint function will extract the `issue_id` slug from the path using the **[Path extractor](https://actix.rs/docs/extractors)** from Actix web and query our database where the issue `id` is equal to the `issue_id` slug of the path.

```rust
#[get("/issue/{issue_id}")]
async fn get_issue(state: web::Data<AppState>, path: web::Path<i32>) -> impl Responder {
    let issue_id = path.into_inner();

    let query: Result<Issue, sqlx::Error> = sqlx::query_as("SELECT * FROM issues WHERE id=$1")
        .bind(issue_id)
        .fetch_one(&state.pool)
        .await;

    let issue = match query {
        Ok(value) => value,
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "status":"FAILED",
                "message":"Something went wrong."
            }));
        }
    };

    HttpResponse::Ok().json(serde_json::json!({
        "status": "SUCCESS",
        "data": issue,
    }))
}

```

### Update issue by `id` endpoint

To update an issue by id we will use slug from the path which will contain the `issue_id` to query our database and update the record if it exists in the database. Before updating the record we can query if the record exists in the database or not:

```rust
#[patch("/issue/{issue_id}")]
async fn update_issue(
    payload: web::Json<NewIssue>,
    state: web::Data<AppState>,
    path: web::Path<i32>,
    req: HttpRequest,
) -> impl Responder {
    let issue_id = path.into_inner();

    let srv_req = ServiceRequest::from_request(req);

    let claim = match clerk_authorize(&srv_req, &state.client, true).await {
        Ok(value) => value.1,
        Err(_) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "status":"Failed",
                "message":"Unauthorized"
            }));
        }
    };

    let query: Result<Issue, sqlx::Error> = sqlx::query_as("SELECT * FROM issues WHERE id=$1")
        .bind(issue_id)
        .fetch_one(&state.pool)
        .await;

    if query.is_err() {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "status":"FAILED",
            "message":"Issue does not exist."
        }));
    }

    match query {
        Ok(issue) => {
            if issue.author != claim.sub {
                return HttpResponse::Unauthorized().json(serde_json::json!({
                    "status":"FAILED",
                    "message":"No authorized to update the issue."
                }));
            }
        }
        Err(_) => {
            return HttpResponse::NotFound().json(serde_json::json!({
                "status":"FAILED",
                "message":"Issue does not exist."
            }));
        }
    }

    let update_query: Result<Issue, sqlx::Error> = sqlx::query_as(
        "UPDATE issues SET title=$1, description=$2, status=$3, label=$4 WHERE id=$5",
    )
    .bind(&payload.title)
    .bind(&payload.description)
    .bind(&payload.status)
    .bind(&payload.label)
    .bind(issue_id)
    .fetch_one(&state.pool)
    .await;

    if update_query.is_err() {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "status":"FAILED",
            "message":"Failed to update the issue"
        }));
    }

    HttpResponse::Ok().json(serde_json::json!({
        "status": "SUCCESS",
        "message":"Updated successfully"
    }))
}

```

### Delete issue by `id` endpoint

This endpoint is for deleting the issue by `id` from the database:

```rust
#[delete("/issue/{issue_id}")]
async fn delete_issue(
    state: web::Data<AppState>,
    path: web::Path<i32>,
    req: HttpRequest,
) -> impl Responder {
    let srv_req = ServiceRequest::from_request(req);

    let claim = match clerk_authorize(&srv_req, &state.client, true).await {
        Ok(value) => value.1,
        Err(_) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "status":"Failed",
                "message":"Unauthorized"
            }));
        }
    };

    let issue_id = path.into_inner();

    let query: Result<Issue, sqlx::Error> = sqlx::query_as("SELECT * FROM issues WHERE id=$1")
        .bind(issue_id)
        .fetch_one(&state.pool)
        .await;

    match query {
        Ok(issue) => {
            if issue.author != claim.sub {
                return HttpResponse::Unauthorized().json(serde_json::json!({
                    "status":"FAILED",
                    "message":"No authorized to delete the issue."
                }));
            }
        }
        Err(_) => {
            return HttpResponse::NotFound().json(serde_json::json!({
                "status":"FAILED",
                "message":"Issue does not exist."
            }));
        }
    }

    let delete_query: Result<Issue, sqlx::Error> = sqlx::query_as("DELETE FROM issues WHERE id=$1")
        .bind(issue_id)
        .fetch_one(&state.pool)
        .await;

    if delete_query.is_err() {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "status":"FAILED",
            "message":"Failed to delete the issue"
        }));
    }

    HttpResponse::Ok().json(serde_json::json!({
        "status": "SUCCESS",
        "message":"Deleted successfully"
    }))
}

```

### Get user by `id`

We need on last endpoint which can fetch the user details by their `user_id`, this API will be used to fetch issue author metadata from Clerk:

```rust
#[get("/user/{user_id}")]
async fn get_user_by_id(state: web::Data<AppState>, path: web::Path<String>) -> impl Responder {
    let user_id = path.into_inner();
    let Ok(user) = User::get_user(&state.client, &user_id).await else {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "status": "FAILED",
            "message": "Unable to retrieve all users",
        }));
    };

    HttpResponse::Ok().json(Into::<UserModel>::into(user))
}

```

Now, let’s add all these endpoints to our `main` function under the `/api` scope which is wrapped by Clerk middleware for protecting our endpoint routes and only allowing authenticated users to access these routes. After adding all the endpoints the `main` function should look like this [main.rs](https://github.com/sourabpramanik/issue-tracker/blob/130170b638ff10771d9dc75eb7479d7178c94d73/backend/src/main.rs#L301C1-L338C2).

One important thing to notice is that this piece of code:

```rust
.service(actix_files::Files::new("/", "./frontend/dist").index_file("index.html"))

```

is going the serve the static pages of the front-end application which we will be creating next from the `./frontend/dist` directory which is generated whenever we build our **Vite** application, this final output is optimized for production. So let’s build the front-end now.

## Build the front-end

`cd` to the `frontend` directory and let’s explore what all we have got.

**[Shadcn UI](https://ui.shadcn.com/docs)**

Shadcn UI is a collection of reusable components that uses **Tailwind CSS** to build its components with great accessibility.

**[SWR](https://swr.vercel.app/)**

SWR is used to create hooks for data fetching and mutations by consuming the APIs we have created in the back-end.

**[Lucide React](https://lucide.dev/)**

Lucide React has a wide range of icons that sits just right with Shadcn UI

### Setting Environment Variable

You can find a `.env.example` file copy the content, create a new file `.env` in the same path, and paste the content in it. From your Clerk dashboard get the `PUBLISHABLE_KEY` and assign it to the variable `VITE_CLERK_PUBLISHABLE_KEY` in the `.env` file:

```bash
VITE_CLERK_PUBLISHABLE_KEY=pk_test_YW1xxxxxxxxxxxxxxxxxxxxxxxxxxxcy5kZXYk

```

### Adding components from Shadcn UI

We already have table and avatar components in the `/frontend/components/ui` directory but we need a few more components to build this application. Run this command to add the [components](https://ui.shadcn.com/docs/components):

```bash
npx shadcn-ui@latest add badge button card dialog form input label select sonner

```

### Schema

We need to represent the structure of the data we are going receive in response from the back-end to keep our front-end application type safe and more predictable.

Create `/frontend/lib/schema.ts` and add `IssueSchema` and `UserSchema` interfaces:

```tsx
export interface IssueSchema {
    id: string | undefined,
    title: string;
    description: string;
    status: "todo" | "inprogress" | "done" | "backlog";
    label: "bug" | "feature" | "documentation";
    author: string;
}

export interface UserSchema {
    id: string,
    first_name: string,
    last_name: string,
    username: string,
    profile_image_url: string,
}

```

In the `IssueSchema`, we have predefined the label and status field value because this helps keep different parts of our application well aware of the incoming data and restricts invalid data input or output.

### Store

We will need to create two stores using **[Zustand](https://docs.pmnd.rs/zustand/migrations/migrating-to-v4#create)**. First, install Zustand:

```bash
npm install zustand

```

- Store for issue `id` that has to be updated/edited

```tsx
import { create } from 'zustand'

type IssueStore = {
    edit_issue_id: string,
    setEditIssueId: (id: string) => void
}
export const useIssueStore = create<IssueStore>((set) => ({
    edit_issue_id: "",
    setEditIssueId: (id: string) => set(() => ({ edit_issue_id: id })),
}))

```

- Store for closing and opening the issue modal

```tsx
type IssueModalStore = {
    isOpen: boolean,
    setOpen: () => void
    setClose: () => void
}
export const useIssueModalStore = create<IssueModalStore>((set) => ({
    isOpen: false,
    setOpen: () => set({ isOpen: true }),
    setClose: () => set({ isOpen: false }),
}))

```

### Custom hooks

We will create the custom hooks using `useSWR` and `userSWRMutation` so that we can revalidate the data after any mutation happens and cache the stale data.

Create `/frontend/lib/hooks.ts` and let's start integrating all the APIs we have created in the back-end. First let's bring all the required schema, hooks, and components into the scope:

```tsx
import useSWR, { Fetcher, useSWRConfig } from "swr"
import useSWRMutation from 'swr/mutation'
import { IssueSchema, UserSchema } from "./schema";
import { toast } from "sonner";
import { useIssueModalStore } from "./store";

```

**Get user hook**

This hook will consume the get user by `id` API we have created before. The first parameter of `useSWR` is the key which is used as an identifier to cache the data and revalidate the data using that key, this key can be a subset of the URL path which can be passed to the fetcher function to fetch or mutate data as well. To know more about the arguments follow this [documentation](https://swr.vercel.app/docs/arguments).

The hook returns an object where the `isLoading` property is a boolean property that sets to true while data is being fetched and a data property that is the returned value of the hook.

```tsx
export const useGetUser = (user_id: string | undefined) => {
    const fetcher: Fetcher<UserSchema, string> = (url) => fetch(url).then(res => res.json())
    const { isLoading, data } = useSWR(`/api/user/${user_id}`, fetcher);
    return { isLoading, data };
}

```

**Get issues hook**

Fetches all the issues for the issues table, consuming get issues API, the response of this API on success will be an array of issues that’s why we have passed `IssuesSchema[]` to the `Fetcher` type:

```tsx
export const useGetIssues = () => {
    const fetcher: Fetcher<IssueSchema[], string> = (url) =>
        fetch(url).then((res) => res.json())
    const { isLoading, data } = useSWR('/api/issues', (url) => fetcher(url));
    return { isLoading, data };
}

```

**Get issue by `id` hook**

This hook uses the get issue by `id` API and returns the one single record that matches that `id` additionally, we have added a condition to call the `fetcher` function only when `id` is not empty:

```tsx
export const useGetIssue = (id: string) => {
    const fetcher: Fetcher<{ data: IssueSchema }, string> = (url) =>
        fetch(url).then((res) => res.json())
    const { data } = useSWR(() => id !== "" ? `/api/issue/${id}` : null, fetcher);

    return { data: data?.data }
}

```

**Create issue hook**

This hook returns a `trigger` method from `useSWRMutation` hook which takes the data to be sent in the request body of the create issue API and an `isMutating` boolean property which we can use to show a loading animation and disable any mutation process while this property is true.

We have used the `setClose` method from the `useIssueModalStore` to close the issue modal once the issue has been created successfully

The data of the payload should match the `IssueSchema` but it should not have the `id` field to it as it is a new record, so to remove `id` field we have used `Omit<IssueSchema, "id">` which creates a new type from the type provide in the first parameter and omits all those fields passed to it after the first parameter in our case it is the `id` field:

```tsx
export const useCreateIssue = () => {
    const { setClose } = useIssueModalStore();

    const create = (url: string, { arg }: { arg: Omit<IssueSchema, "id"> }) => fetch(url, {
        method: "POST",
        headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
        },
        body: JSON.stringify(arg),
    }).then(res => res.json())

    const { mutate: revalidateIssuesList } = useSWRConfig();

    const { isMutating, trigger } = useSWRMutation("/api/issue", create, {
        onSuccess() {
            toast.success("Issue has been created.");
            setClose();
            revalidateIssuesList("/api/issues")
        },
        onError(err) {
            if (err.message) {
                toast.error(err.message);
            } else {
                toast.error("Failed to create issue");
            }
        },
    })

    return { isMutating, trigger }
}

```

> 🗨️ We need specify the content type header as `application/json` in the fetch calls because by default fetch API sets the content type header to `text/plain` which causes an incorrect content error as the back-end we have created expects a JSON payload.
> 

**Update/Edit issue hook**

This hook consumes the update issue by `id` API and similar to the create issue hook it also returns `isMutating` property and `trigger` method.

We have used the `setClose` method from the `useIssueModalStore` to close the issue modal once the issue has been updated successfully

```tsx
export const useEditIssue = () => {
    const { setClose } = useIssueModalStore();

    const edit = (url: string, { arg }: { arg: IssueSchema }) => fetch(`${url}/${arg.id}`, {
        method: "PATCH",
        headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
        },
        body: JSON.stringify(arg),
    }).then(res => res.json())

    const { mutate: revalidateIssuesList } = useSWRConfig();

    const { isMutating, trigger } = useSWRMutation("/api/issue", edit, {
        onSuccess() {
            toast.success("Issue has been updated.");
            setClose();
            revalidateIssuesList("/api/issues")
        },
        onError(err) {
            if (err.message) {
                toast.error(err.message);
            } else {
                toast.error("Failed to update issue");
            }
        },
    })

    return { isMutating, trigger }
}

```

**Delete issue hook**

One final API integration, the delete API takes the `id` and also returns an object with `isMutating` field and `trigger` method:

```tsx
export const useDeleteIssue = () => {
    const { setClose } = useIssueModalStore();

    const remove = (url: string, { arg }: { arg: { id: string } }) => fetch(`${url}/${arg.id}`, {
        method: "DELETE",
    }).then(res => res.json())

    const { mutate: revalidateIssuesList } = useSWRConfig();

    const { isMutating, trigger } = useSWRMutation("/api/issue", remove, {
        onSuccess() {
            toast.success("Issue has been deleted.");
            setClose();
            revalidateIssuesList("/api/issues")
        },
        onError(err) {
            if (err.message) {
                toast.error(err.message);
            } else {
                toast.error("Failed to delete issue");
            }
        },
    })

    return { isMutating, trigger }
}

```

### Issue modal

Create an issue modal in `/frontend/components/issue-modal.tsx`.

The issue modal will have a form with a title input field, a description input field, a status select input field, and a label select input field.

**Using Zod**

First, we need to install Zod to define the schema for the form and add rules with helper messages to validate the user input:

```bash
npm install zod

```

Next, define the form schema:

```tsx
import { z } from "zod";
//...rest of the imports

const status = ["todo", "inprogress", "done", "backlog"] as const;
const label = ["bug", "feature", "documentation"] as const;
const formSchema = z.object({
  title: z.string().min(3, {
    message: "title must be at least 3 characters.",
  }),
  description: z.string().min(5, {
    message: "title must be at least 5 characters.",
  }),
  status: z.enum(status, {
    required_error: "You need to select a status.",
  }),
  label: z.enum(label, {
    required_error: "You need to select a label.",
  }),
  author: z.string({ required_error: "Author is required" }),
});

```

In the above code, we have created a label and a status enum for the select input field option. It should be the same as the expected label and status field value of the `IssueSchema`

**Using React Hook Form**

Now, we need to install [**React Hook Form](https://react-hook-form.com/) f**or field validation and field state management:

```tsx
npm install react-hook-form

```

React Hook Form has a `useForm` hook which is used to handle the `onChange` event and validate the form on the fly. It needs a `type` parameter which will be the form definition consisting of the details of each field the form is having. We can infer the type by using the `formSchema` we have defined using Zod.

`useForm` hook accepts two options a `resolver` and `defaultValues`. For the resolver, we need to integrate preferred schema validation. We will use Zod resolver for validation which will take the `formSchema` as a parameter to apply the validation rules.

For the `defaultValues` for the form, but for the author we will not create a form element rather we will provide the user `id` which we can get from `useUser` hook from Clerk because we only want the user who is creating the issue to be the author of.

```tsx
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { useUser } from "@clerk/clerk-react";
//...rest of the imports

function IssueCard() {
	const { user } = useUser();
	const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: "",
      description: "",
      status: "todo",
      label: "bug",
      author: user?.id,
    },
  });

//...rest of the code

}

```

**Conditional mutation and rendering for creation and update**

So far we have added all the required hooks and components that can be used to create and update an issue. Now, we need to render the modal differently for the update than how it is for the creation.

For the update, we need the issue `id` from `useIssueStore` hook and fetch the issue first using `useGetIssue` once we have retrieved the issue successfully we can update the state of the form using `useEffect` hook and only allow the author to update their own created issues:

After that, we will define the `onSubmit` handler function to conditionally create an issue using `useCreateIssue` hook or update an issue using `useEditIssue` hook:

```tsx
import { useIssueStore } from "@/lib/store";
import { useCreateIssue, useEditIssue, useGetIssue } from "@/lib/hooks";
//...rest of the imports

function IssueCard() {
	const { edit_issue_id } = useIssueStore();
  const { data: issue } = useGetIssue(edit_issue_id);

	const { isMutating: createMutating, trigger: createTrigger } =
    useCreateIssue();
  const { isMutating: editMutating, trigger: editTrigger } = useEditIssue();

  function onSubmit(values: z.infer<typeof formSchema>) {
    edit_issue_id === ""
      ? createTrigger(values)
      : editTrigger({ id: edit_issue_id, ...values });
  }

  //Check for the author is editing or not
  const noAuth = edit_issue_id !== "" && user?.id !== issue?.author;

}

```

Finally, your issue modal will look like this [**issue-modal.tsx**](https://github.com/sourabpramanik/issue-tracker/blob/130170b638ff10771d9dc75eb7479d7178c94d73/frontend/src/components/issue-modal.tsx#L1C1-L225C2)

### Issues table

Create a new directory inside the components directory `issues-table`, inside this directory create two files `index.tsx` , and `row.tsx`

**Edit the `row.tsx` file**

We will define `Row` component which will take `props` having the type set to `IssueSchema`.

Each row will have 6 cells for the author, title, description (truncated), status, label,  and last cell for edit and delete buttons.

The edit button will set the issue `id` to be edited using `setEditIssueId` from `useIssueStore` hook and open up the modal. The delete button will trigger the delete API in the `useDeleteIssue` hook.

Both of these buttons is conditionally rendered based on the condition that if the signed-in user is an author of the issue then they can mutate the issue or else they can just view the issue.

Please find the complete code here [row.tsx](https://github.com/sourabpramanik/issue-tracker/blob/130170b638ff10771d9dc75eb7479d7178c94d73/frontend/src/components/issue-table/row.tsx#L1C1-L102C20).

**Edit the `index.tsx` file of the `issue-table` component**

Here you can find the complete code for the issue table **[index.tsx](https://github.com/sourabpramanik/issue-tracker/blob/130170b638ff10771d9dc75eb7479d7178c94d73/frontend/src/components/issue-table/index.tsx#L1C1-L64C2)**.

I have added the create new issue button on top of the table component which on click event sets the `edit_issue_id` store to an empty string to ensure we do not use the update logic in the issue modal and then set the modal to open up.

### Update `App.tsx` file

Now we can import our `IssuesTable` component and render it up:

```tsx
import { SignIn, SignedIn, SignedOut, UserButton } from "@clerk/clerk-react";
import IssuesTable from "@/components/issue-table";

function App() {
  return (
    <main>
      <SignedOut>
        <SignIn />
      </SignedOut>
      <SignedIn>
        <div className="p-20 flex flex-col items-center space-y-7">
          <div className="fixed top-6 right-6">
            <UserButton afterSignOutUrl="/" />
          </div>
          <IssuesTable />
        </div>
      </SignedIn>
    </main>
  );
}

export default App;

```

### Update `main.tsx` file

Add the `Toaster` component from `sonner` and `IssueModal` :

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { ClerkProvider } from "@clerk/clerk-react";
import { Toaster } from "@/components/ui/sonner";
import IssueModal from "@/components/issue-modal";

// Import your publishable key
const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!PUBLISHABLE_KEY) {
  throw new Error("Missing Publishable Key");
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
      <App />
      <Toaster />
      <IssueModal />
    </ClerkProvider>
  </React.StrictMode>
);

```

## Run the application

First, build your frontend application using this command:

```bash
npm run build
```

This will generate an optimized build in the `/frontend/dist` directory.

Finally run the backend using:

```bash
cargo shuttle run --port 8000
```

Open the highlighted URL in the browser window:

<img width="960" alt="Screenshot 2024-02-06 082641" src="[https://gist.github.com/assets/61370770/8a22b566-a930-494a-8ba6-cd92481a0113](https://gist.github.com/assets/61370770/8a22b566-a930-494a-8ba6-cd92481a0113)">

# **Deployment**

Now you can deploy your app in the Shuttle’s managed platform by running **`cargo shuttle deploy`** (with the **`--allow-dirty`** flag if you have uncommitted changes). 

One important note is that the deployment using the **development** keys from Clerk will work just fine. But if you happen to use the **Production Instance** of Clerk then you will need to update the **PUBLISHABLE_KEY** on the front-end and **CLERK_SECRET_KEY** on the back-end with **Live** keys. Now since you have moved to production you will also need to set up the domain or subdomain of your application in Clerk and add the CNAME records that you will get from the Clerk dashboard to your DNS record for managing sessions, loading portal using your domain, sending verification emails, and using custom callback URL. Since this process can be different based on your domain provider and management system, I will leave a link to the Clerks documentation on [**Deploy to production**](https://clerk.com/docs/deployments/overview).

# Closing in

Thanks for reading!! That's a lot but I hope you have managed to deploy your application and had a good learning experience. The deployment process in Shuttle is very seamless and the performance is very top-notch. Being a Rust Native platform Shuttle provides huge improvements and optimizations to the Rust applications like the ones we saw in this article.