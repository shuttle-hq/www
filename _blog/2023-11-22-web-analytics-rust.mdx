---
title: "Building & Deploying A Web Analytics Tool with JS, htmx and Rust"
description: This article documents how you can build a simple privacy-respecting analytics tool using a custom JavaScript web analytics script and handle the backend with Rust - dashboard included. 
author: josh
tags: [rust, web analytics, htmx, frontend, guide]
thumb: ssg-in-rust-thumb.png 
cover: ssg-in-rust-thumb.png
date: '2023-11-22T15:30:00'
---

With privacy becoming more and more of a concern on the Internet, it is important to learn how to build tools that respect user privacy. According to [this 2020 study](https://arxiv.org/pdf/1911.09964.pdf) saying things like "ensuring a proper functionality and legal compliance of a cookie banner is usually left to the website publisher and is completely obscure for the website visitor", it's not particularly clear  how users' privacy is being respected (if it is) since cookie banners and HTML elements that serve similar functionality tend to be very intrusive and worsen the user experience. To this extent, we've decided to show you how you can roll your own privacy-respecting analytics, with a backend written in Rust and a dashboard written using the [`tera`](https://keats.github.io/tera) HTML templating crate and [htmx](https://htmx.org/), which is a lightweight JavaScript library for dynamic web development, enabling real-time content updates without full-page reloads. 

The advantages of building a dashboard with htmx, powered by HTML templating, are as follows:
- htmx itself is quite a lightweight library 
- No JS knowledge required - you can focus on using HTML, CSS and Rust!
- You can focus on the dealing with the data
 
If you're interested in deploying and trying this out for yourself, you can follow the instructions below to get started quickly:
1) Run `cargo shuttle init --from joshua-mo-143/shuttle-analytics-ex` and follow the prompt
2) `cd` to the folder
3) Run `cargo shuttle deploy --allow-dirty` and your analytics tool is live!
4) You can add a script with the source as the `/script.js` route to any web page you own and it will now start tracking users.

Don't forget to make sure that `cargo-shuttle` is installed and that you're logged in! You can also visit the repo [here.](https://www.github.com/joshua-mo-143/shuttle-analytics-ex)

## Getting Started
You'll need to use `cargo shuttle init --template axum` to get started (if you don't have it installed, you can use `cargo install cargo-shuttle` then log in using `cargo shuttle login` to get started!). Once you're done, you'll want to check out the dependency list below (feel free to copy and paste the full list or use `cargo add` to add them individually):

```toml
# Cargo.toml
[dependencies]
axum = { version = "0.6.20", features = ["headers", "macros"] }
chrono = { version = "0.4.31", features = ["clock", "serde"] }
serde = { version = "1.0.190", features = ["derive"] }
serde_json = "1.0.108"
shuttle-axum = "0.33.0"
shuttle-metadata = "0.33.0"
shuttle-runtime = "0.333.0"
shuttle-shared-db = { version = "0.33.0", features = ["postgres"] }
sqlx = { version = "0.7.2", features = ["runtime-tokio-native-tls", "postgres", "chrono"] }
tera = "1.19.1"
tokio = "1.28.2"
url = { version = "2.4.1", features = ["serde"] }
```

Next, you will want to add some migrations like so:
```rust
# migrations.sql
CREATE TABLE IF NOT EXISTS stats (
    id SERIAL PRIMARY KEY,
    uri VARCHAR NOT NULL,
    domain VARCHAR NOT NULL,
    session_uuid VARCHAR NOT NULL,
    date_time TIMESTAMP WITH TIME ZONE NOT NULL,
    duration INT NOT NULL
);
```

Now we want to go into our main function and set up our macro annotations! Normally at this point we would probably want to spin up a Docker container for our local database and then use environment variables for Shuttle, but we can let Shuttle handle all of this by adding macros to our main function like so:
```rust
// src/main.rs
use sqlx::PgPool;
use shuttle_metadata::Metadata;

#[derive(Clone)]
pub struct AppState {
    db: PgPool,
    metadata: Metadata
}

#[shuttle_runtime::main]
async fn main(
    #[shuttle_shared_db::Postgres] db: PgPool,
    #[shuttle_metadata::ShuttleMetadata] metadata: Metadata,
) -> shuttle_axum::ShuttleAxum {
    db.execute(include_str!("../schema.sql")).await.unwrap();

    // if running in debug mode (local), use localhost
    // else if in release mode, use the deployed url
    let domain = match metadata.env  {
        Environment::Local => "http://localhost:8000".to_string(),
        Environment::Deployment => format!(
            "https://{}.shuttleapp.rs",
            metadata.project_name
        )
    };

    let state = AppState { db, domain };

    let router = Router::new()
        .route("/", get(hello_world))
        .with_state(state);

    Ok(router.into())
}
```

We'll also want to set up a `Shuttle.toml` file that lets Shuttle know where our static files are:
```toml
# Shuttle.toml
assets = ["templates/*"]
```

## Setting up CSS
For CSS we need to write a CSS file and then return a function handler that sends the CSS with the correct mime type so that our web pages can read it. Let's first declare our CSS file:
```css
/* templates/styles.css */
button {
    border: 1px solid rgb(100, 100, 100);
    background-color: rgb(240, 240, 240);
    font-size: 1rem;
    margin: 0;
    padding: 10px 10px;
}

button:hover {
background-color: rgb(200, 200, 200);
}

button + button {
   height: 50px;
}

#dashboard {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

#content {
    display: flex;
    text-align: center;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}
```
As you can see, the CSS is quite minimal - but by doing it this way, it's much easier to focus on the numbers.

We can set up a function handler for returning the CSS body that our webpages can retrieve like so:
```rust
// src/frontend.rs
pub async fn styles() -> impl IntoResponse {
    Response::builder()
        .status(StatusCode::OK)
        .header("Content-Type", "text/css")
        .body(include_str!("../templates/styles.css").to_owned())
        .unwrap()
```

Now we just need to hook this up to our `axum::Router` as the `/styles.css` route and we're done!

## Setting up htmx

htmx is quite simple to set up - we can add it to the head of our `base.html` file:

```html
<!-- templates/base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuttle Analytics</title>
    <link href="./styles.css" rel="stylesheet">
    <!-- this script line is taken from the htmx documentation which you can find here: https://htmx.org/docs/ -->
    <script src="https://unpkg.com/htmx.org@1.9.9" integrity="sha384-QFjmbokDn2DjBjq+fM+8LUIVrAgqcNW2s0PjAxHETgRn9l4fvX31ZxDxvwQnyMOX" crossorigin="anonymous"></script>
</head>
<body>
    <div id="content">
    <!-- as you can see, we have a {% %} block here for content - which we will declare later -->
    {% block content %}{% endblock content %}
    </div>
</body>
</html>
```

htmx works by using requests that expect HTML fragments to get returned - in turn, it allows you to use almost any html element you want to API calls, being able to create a specific trigger for the API call. You can also select what element the resulting HTML fragment will replace. This is a great features set for us as it means we can use it with Tera to return dynamic HTML fragments!

Check out the following button that uses htmx (with Tera) as an example:
```html
<button hx-get="/stats/uri?domain={{ website.uri }}" 
    hx-target="#dashboard">
    {{website.uri}} - {{ website.count }}
</button>
```
This button, when clicked, makes a request to the `/stats/uri` endpoint with an added query parameter of whatever the user clicks on, and the resulting HTML will replace the contents of whatever is inside the HTML element with an id of "dashboard". The button text is rendered dynamically based on whatever variables we give it.

## Setting up Tera
Tera is a HTML templating library that uses Jinja-like syntax to parse HTML pages at runtime, as well as having all the regular fixtures like conditionals, for-loops and functions as well as child templates. A base HTML page for keeping our HTML head on might look like this:
```html
<!-- templates/base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuttle Analytics</title>
    <link href="./styles.css" rel="stylesheet">
</head>
<body>
    <div id="content">
    <!-- as you can see, we have a {% %} block here for content - which we will declare later -->
    {% block content %}{% endblock content %}
    </div>
</body>
</html>
```

To set up Tera, we need to declare a new `Tera` instance and use the `add_template_files` method to add a vector of tuples containing our file locations from which we want to serve, as well as the name of the file held by Tera so we can easily refer to it when rendering it later on in our frontend:
```rust
// src/main.rs
// ... rest of your main function code
let mut tera = Tera::new("templates/*").unwrap();

tera.add_template_files(
    vec![
        ("templates/script.js", Some("script")),
        ("templates/domain.html", Some("domain")),
        ("templates/uri.html", Some("uri")),
        ("templates/about.html", Some("about")),
        ("templates/index.html", Some("index")),
    ])
.unwrap();
// ... rest of your main function code
```

Now that we've added our templates, we can use them by adding the Tera template as an extension to our `axum::Router`:
```rust
let router = Router::new()
    .route("/", get(homepage))
    .route("/dashboard", get(dashboard))
    .route("/stats/domains", get(query_domain))
    .route("/stats/uri", get(query_uri))
    .route("/about", get(about))
    .route("/script.js", get(script))
    .route("/styles.css", get(styles))
    .route("/push", post(submit_analytics))     
    .with_state(state)
    .layer(Extension(Arc::new(tera)));
```


Now that we've added our sources for HTMl files, we can now write our handler like this to return a HTML response:
```rust
pub async fn homepage(
    Extension(frontend): Extension<Arc<Tera>>,
) -> impl IntoResponse {
    Html(frontend.render("index", &Context::new()).unwrap())
}
```

A HTML file that includes our base HTML file might look like this - we extend the `base.html` file, then fill out whatever blocks are in the `base.html` file - in this case, the content block.
```html
<!-- templates/index.html -->
{% extends 'base.html' %}

{% block content %}
    <h1>Shuttle Analytics - Home</h1>
    <a href="/about">Go to the About page</a>
    <a href="/dashboard">Go to the Dashboard page</a>
{% endblock content %}
```

Interested in finding out more about Tera? You can find their docs [here.](https://keats.github.io/tera/)

## Writing An Analytics Script

Next,  we'll need to write some JavaScript so we can collect some (anonymous) data. We will use search parameters to hold a randomly-generated, anonymous user ID and if the referrer from the last page has the same domain host, use the same UUID - otherwise, generate a new one. The UUID is necessary so that we can distinguish user sessions from each other.

We then replace the last page history (the current page) with the flat URL so the user doesn't see the analytics tracking parameters (having it in the URL makes the URL significantly longer and more ugly when shared), as well as taking note of what the current time is. Once the page loads, we then add the UUID to every anchor link where the page has the same host as the current webpage. We also add an event trigger on page visibility change to Show so that the page will automatically send a HTTP request to our analytics endpoint through our JS web analytics script.

```javascript
const url = new URL(window.location.href);
const searchParams = url.searchParams;

const uuid = searchParams.has("uid") && referrer.includes(window.location.host) ? searchParams.get("uid") : crypto.randomUUID();

let urlWithoutUid = url.searchParams.delete("uid");

history.replaceState({}, "", urlWithoutUid);
let datetime_entered = Date.now();
let datetime_entered_isostring = new Date().toISOString();

document.addEventListener("load", () => {
let links = document.querySelectorAll('a');

for (let i = 0; i < links.length; i++) {
        if (links[i].href.includes(window.location.host)) {
                links[i].href += "?uid=" + uuid;
        }
}
})

document.addEventListener("visibilitychange", send_logs(), false);

async function send_logs() {
    if (!Document.hidden) {
    let res = await fetch("{{domain}}/push", {
        method: "POST",
        keepalive: true,
        headers: {
            "content-type":"application/json",
        },
        body: JSON.stringify({
            "uri": window.location.href,
            "sessionUuid": uuid,
            "domain": window.location.host,
            "dateTime": datetime_entered_isostring,
            "duration": 0
        }),
    });
    }
}
```

As you may have seen above, we injected a variable called `domain` in our above script - we can parse this from our template that we added to our Tera instance, then pass it in as the body of a HTML response to create a fully working script file:
```rust
pub async fn script(
    State(state): State<AppState>,
    Extension(frontend): Extension<Arc<Tera>>,
) -> impl IntoResponse {
    let mut ctx = Context::new();
    ctx.insert("domain", &state.domain);

    let html = frontend.render("script", &ctx).unwrap();

    Response::builder()
        .status(StatusCode::OK)
        .header("Content-Type", "text/javascript")
        .body(html)
        .unwrap()
}
```
When we're writing a HTML page, we can now use this route as the source of a script in the HTML head of any web page that we want:
```html
<script src="http://localhost:8000/script.js"></script>
```

We also need to set up an endpoint where the analytics will actually be received, which we can do so like so:
```rust
use chrono::{DateTime, Utc};
use serde::Deserialize;
use axum::{response::IntoResponse, TypedHeader, headers::Origin, http::StatusCode, extract::State};

#[derive(Deserialize)]
pub struct AnalyticsSubmission {
    uri: String,
    #[serde(rename = "sessionUuid")]
    session_uuid: String,
    #[serde(rename = "dateTime")]
    date_time: DateTime<Utc>,
    duration: i32,
    domain: String,
}

pub async fn submit_analytics(
    TypedHeader(origin): TypedHeader<Origin>,
    State(state): State<AppState>,
    Json(stats): Json<AnalyticsSubmission>,
) -> impl IntoResponse {
// if the URI isn't the same as the hostname, auto-return Bad Request
    if !stats.uri.contains(origin.hostname()) {
        println!(
            "A user tried to submit analytics from {origin} but the URI was from {}",
            stats.uri
        );
        return StatusCode::BAD_REQUEST;
    }

    sqlx::query(
        "INSERT INTO stats
        (uri, session_uuid, date_time, duration, domain)
        VALUES
        ($1, $2, $3, $4, $5)",
    )
    .bind(stats.uri)
    .bind(stats.session_uuid)
    .bind(stats.date_time)
    .bind(stats.duration)
    .bind(stats.domain)
    .execute(&state.db)
    .await
    .unwrap();

    StatusCode::OK
}
```

## Dashboard
Next we'll focus on making the dashboard. Internally we'll be using a few endpoints to be able to grab data, but externally the viewer will only see three pages:
- The base route, where they'll see the "About" page
- The About page which also has a script with the source linked to our own script for testing
- A dashboard where we can fetch basic stats for domains 

Let's have a look at what our basic page will look like for the dashboard. To start with, we'll make a query that groups together the total count of how many records there are per domain - meaning, how many visits there were to a given website that has our analytics script attached to it, then we can declare a new `tera::Context`, attach the data to it and return the webpage:
```rust
// src/frontend.rs
#[derive(Serialize, sqlx::FromRow)]
struct Domain {
    domain: String,
    count: i64,
}

pub async fn dashboard(
    State(AppState { db, .. }): State<AppState>,
    Extension(frontend): Extension<Arc<Tera>>,
) -> impl IntoResponse {
// Note that if there's an error the page will automatically have error text from what we've written
// so no need to return a page error
    let data =
        match sqlx::query_as::<_, Domain>(r#"SELECT domain, COUNT(*) FROM stats GROUP BY domain"#)
            .fetch_all(&db)
            .await
        {
            Ok(res) => Some(res),
            Err(e) => {
                println!("Encountered an error trying to fetch analytics on the homepage: {e}");

                None
            }
        };

    let mut ctx = Context::new();
    ctx.insert("data", &data);

    Html(frontend.render("dashboard", &ctx).unwrap())

}
```

Then we can write up the Dashboard page HTML:
```html
<!-- templates/dashboard.html -->
{% extends 'base.html' %}

{% block content %}
    <h1>Shuttle Analytics - Dashboard</h1>
<a href="/">Back to the homepage</a>
    <div id="dashboard">
        <h2> Click below to go to check out the stats for the relevant website. </h2>
    <!-- if data exists, map it to an array of buttons - if not, return "No data collected :(" -->
    {% if data %}
    {% for website in data %}
    <button hx-get="/stats/domains?domain={{ website.domain }}" hx-target="#dashboard">{{ website.domain}} - {{website.count}}</button>
    {% endfor %}
    {% else %}
        <p> No data collected :( </p>
    {% endif %}
    </div>
{% endblock content %}
```
Note that for the links, we are actually using buttons that utilise the `hx-get` attribute and target the `div` with the `dashboard` ID - this is so that when we are navigate through links, the content will simply replace whatever is inside the dashboard div so we can use the `/dashboard` route to contain all the frontend data.

For the dashboard page where we want to have a list of hits for a domain per URI, we can do this quite easily by grabbing the URI with an aggregated record count of each one from the database where the domain in the record is the same as in the query parameter (when a record gets submitted to the database, the URI will always be the same as the domain so no need to worry) - here we have also added a limit to only the last 7 days so that if we end up having a long list of data, we won't be waiting for a long time to get results:
```rust
// src/frontend.rs
#[derive(Deserialize)]
pub struct DomainStatsQuery {
    domain: Url,
}

pub async fn query_domain(
    State(AppState { db, .. }): State<AppState>,
    Extension(frontend): Extension<Arc<Tera>>,
    Query(query): Query<DomainStatsQuery>,
) -> impl IntoResponse {
    let data = match sqlx::query_as::<_, DomainUri>(
        r#"SELECT uri, COUNT(*) FROM stats
    WHERE
    domain = $1
    and
    DATE_PART('day', CURRENT_TIMESTAMP - DATE_TIME) BETWEEN 0 AND 7
    GROUP BY uri"#,
    )
    .bind(&query.domain.clone().into_string())
    .fetch_all(&db)
    .await
    {
        Ok(res) => Some(res),
        Err(e) => {
            println!("Encountered an error trying to fetch analytics on the homepage: {e}");

            None
        }
    };

    let mut ctx = Context::new();
    ctx.insert("data", &data);
    ctx.insert("domain", &query.domain);
    Html(frontend.render("domain", &ctx).unwrap())
}
```
See the HTML frontend below for how the page would look when it is slotted into the Dashboard div:
```html
<!-- templates/domain.html -->
{% extends 'base.html' %}

{% block content %}
    <button hx-get="/dashboard" hx-target="body">Back to main dashboard</button>
    <h1>Stats by Domain - {{domain}}</h1>
    <p>Number of page hits from the last 30 days, sorted by URI:</p>
    {% if data %}
    {% for website in data %}
        <button hx-get="/stats/uri?domain={{ website.uri }}" hx-target="#dashboard">{{website.uri}} - {{ website.count }}</a>
    {% endfor %}
    {% else %}
            <p> No data :( </p>
    {% endif %}
{% endblock content %}
```
As noted above, the links for navigating within the dashboard utilise htmx so that we can simply replace the content that is on the webpage instead of using actual page navigation. 

For the URI querying endpoint, it is much the same as the above, except that navigating back presents a slight issue: where `window.location.host` also gives us the port in JavaScript, in Rust it doesn't - so we need to manually parse this based on whether or not the port exists:
```rust
pub async fn query_uri(
    State(AppState { db, .. }): State<AppState>,
    Extension(frontend): Extension<Arc<Tera>>,
    Query(query): Query<DomainStatsQuery>,
) -> impl IntoResponse {
    let data = match sqlx::query_as::<_, UriCounter>(
        r#"SELECT date(date_time), COUNT(*) FROM stats
    WHERE
    uri = $1
    and
    DATE_PART('day', CURRENT_TIMESTAMP - DATE_TIME) BETWEEN 0 AND 7
    GROUP BY date"#,
    )
    .bind(&query.domain.clone().into_string())
    .fetch_all(&db)
    .await
    {
        Ok(res) => Some(res),
        Err(e) => {
            println!("Encountered an error trying to fetch analytics on the homepage: {e}");

            None
        }
    };


    let domain_base = format!(
            "{}{}{}",
            query.domain.host_str().unwrap(),
            if query.domain.port().is_some() {
                ":"
            } else {
                ""
            },
            if query.domain.port().is_some() {
                query.domain.port().unwrap().to_string()
            } else {
                String::new()
            }
        );

    let mut ctx = Context::new();
    ctx.insert("data", &data);
    ctx.insert("domain", &query.domain.clone().into_string());
    ctx.insert("domain_base", &domain_base);
    Html(frontend.render("uri", &ctx).unwrap())
}
```
See the HTML below:
```html
<!-- templates/uri.html -->
{% extends 'base.html' %}

{% block content %}
    <button hx-get="/stats/domains?domain={{domain_base}}" hx-target="#dashboard">Back to domain page</button>
    <h1>Stats by URI - {{domain}}</h1>
    <p>Number of page hits from the last 7 days, sorted by date:</p>
    {% if data %}
    {% for website in data %}
        <p> {{ website.date }} - {{ website.count }}
    {% endfor %}
    {% else %}
        <p> No data :( </p>
    {% endif %}

{% endblock content %}
```

## Deployment
Now that we're done, all you need to do is `cargo shuttle deploy` (with the `--ad` flag if on a dirty Git branch) and you're up and away! When it's finished deploying, you'll see your project deployment URL as well as any resources you were provisioned.

## Finishing Up
Thanks for reading! I hope this has given some insight into how you can write Rust htmx assisted web applications, as well as building privacy-respecting web analytics tools.

A couple of ideas for extending this example:
- Lock the dashboard behind authentication
- Add more periods for viewing data
